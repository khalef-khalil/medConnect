const { v4: uuidv4 } = require('uuid');
const { dynamoDB, TABLES, S3_CONFIG } = require('../config/aws');
const { logger } = require('../utils/logger');
const { uploadBase64File } = require('../services/file.service');

/**
 * Create a new video session for an appointment
 */
exports.createVideoSession = async (req, res) => {
  try {
    const { appointmentId } = req.body;
    const { userId, role } = req.user;

    if (!appointmentId) {
      return res.status(400).json({ message: 'Appointment ID is required' });
    }

    // Verify appointment exists
    const appointmentParams = {
      TableName: TABLES.APPOINTMENTS,
      Key: { appointmentId }
    };

    const appointmentResult = await dynamoDB.get(appointmentParams).promise();
    
    if (!appointmentResult.Item) {
      return res.status(404).json({ message: 'Appointment not found' });
    }

    const appointment = appointmentResult.Item;

    // Verify user has permission to join this appointment
    if (role !== 'admin' && 
        userId !== appointment.patientId && 
        userId !== appointment.doctorId) {
      return res.status(403).json({ message: 'You do not have permission to access this appointment' });
    }

    // Check if there's already a session for this appointment
    const existingSessionParams = {
      TableName: TABLES.APPOINTMENTS,
      FilterExpression: 'appointmentId = :appointmentId',
      ExpressionAttributeValues: {
        ':appointmentId': appointmentId
      }
    };

    // For a real implementation, you would have a separate video sessions table
    // This is a simplified version just to demonstrate the concept

    // Generate session ID and tokens
    // In a real implementation, this would interact with a video service (e.g., Twilio, Agora)
    const sessionId = uuidv4();
    
    // Update appointment with session info
    const updateParams = {
      TableName: TABLES.APPOINTMENTS,
      Key: { appointmentId },
      UpdateExpression: 'set videoSessionId = :sessionId, videoSessionCreatedAt = :createdAt, updatedAt = :updatedAt',
      ExpressionAttributeValues: {
        ':sessionId': sessionId,
        ':createdAt': new Date().toISOString(),
        ':updatedAt': new Date().toISOString()
      },
      ReturnValues: 'ALL_NEW'
    };

    const updatedResult = await dynamoDB.update(updateParams).promise();

    // Create response with session details
    // In a real implementation, you would generate tokens for each participant
    const sessionDetails = {
      sessionId,
      appointmentId,
      createdAt: new Date().toISOString(),
      patientId: appointment.patientId,
      doctorId: appointment.doctorId,
      // This would be generated by the video service in a real implementation
      connectionDetails: {
        apiKey: 'sample-api-key',
        sessionUrl: `https://video.example.com/session/${sessionId}`
      }
    };

    res.status(201).json({
      message: 'Video session created successfully',
      session: sessionDetails
    });
  } catch (error) {
    logger.error('Error in createVideoSession function:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

/**
 * Get video session details by appointment ID
 */
exports.getVideoSession = async (req, res) => {
  try {
    const { appointmentId } = req.params;
    const { userId, role } = req.user;

    // Verify appointment exists
    const appointmentParams = {
      TableName: TABLES.APPOINTMENTS,
      Key: { appointmentId }
    };

    const appointmentResult = await dynamoDB.get(appointmentParams).promise();
    
    if (!appointmentResult.Item) {
      return res.status(404).json({ message: 'Appointment not found' });
    }

    const appointment = appointmentResult.Item;

    // Verify user has permission to access this appointment
    if (role !== 'admin' && 
        userId !== appointment.patientId && 
        userId !== appointment.doctorId) {
      return res.status(403).json({ message: 'You do not have permission to access this appointment' });
    }

    // Check if the session exists
    if (!appointment.videoSessionId) {
      return res.status(404).json({ message: 'No video session found for this appointment' });
    }

    // Create response with session details
    const sessionDetails = {
      sessionId: appointment.videoSessionId,
      appointmentId,
      createdAt: appointment.videoSessionCreatedAt,
      patientId: appointment.patientId,
      doctorId: appointment.doctorId,
      // This would be generated by the video service in a real implementation
      connectionDetails: {
        apiKey: 'sample-api-key',
        sessionUrl: `https://video.example.com/session/${appointment.videoSessionId}`
      }
    };

    res.status(200).json({ session: sessionDetails });
  } catch (error) {
    logger.error('Error in getVideoSession function:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

/**
 * Save a video recording to S3
 */
exports.saveRecording = async (req, res) => {
  try {
    const { appointmentId } = req.params;
    const { recording } = req.body;
    const { userId, role } = req.user;

    if (!recording) {
      return res.status(400).json({ message: 'Recording data is required' });
    }

    // Verify appointment exists
    const appointmentParams = {
      TableName: TABLES.APPOINTMENTS,
      Key: { appointmentId }
    };

    const appointmentResult = await dynamoDB.get(appointmentParams).promise();
    
    if (!appointmentResult.Item) {
      return res.status(404).json({ message: 'Appointment not found' });
    }

    const appointment = appointmentResult.Item;

    // Verify user has permission to save recording for this appointment
    if (role !== 'admin' && role !== 'doctor' && 
        userId !== appointment.doctorId) {
      return res.status(403).json({ message: 'You do not have permission to save recordings for this appointment' });
    }

    // Upload recording using file service
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const fileName = `${appointmentId}_${timestamp}`;
    const recordingUrl = await uploadBase64File(
      recording,
      fileName,
      S3_CONFIG.PREFIXES.RECORDINGS
    );

    // Update appointment with recording info
    const updateParams = {
      TableName: TABLES.APPOINTMENTS,
      Key: { appointmentId },
      UpdateExpression: 'set recordingUrl = :recordingUrl, updatedAt = :updatedAt',
      ExpressionAttributeValues: {
        ':recordingUrl': recordingUrl,
        ':updatedAt': new Date().toISOString()
      },
      ReturnValues: 'ALL_NEW'
    };

    await dynamoDB.update(updateParams).promise();

    res.status(200).json({
      message: 'Recording saved successfully',
      recordingUrl
    });
  } catch (error) {
    logger.error('Error in saveRecording function:', error);
    res.status(500).json({ message: 'Server error' });
  }
}; 